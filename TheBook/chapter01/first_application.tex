
%使用xelatex编译
%版权所有，翻版必究
%本文件由程序自动生成，任何修改将被覆盖
%2019 年 01 月 09 日




%

\FloatBarrier
\section{
第一个程序
}\label{s100210}


\FloatBarrier
\subsection{
本书的工程项目
}\label{ss001u10}


读者可以使用Qt Creator打开“QtQmlBook.pro”。
在Windows平台下，读者
也可以修改“build\underline{\hspace{0.5em}}msvc.bat”，从而使用Visual Studio。

如\lstlistingname\ \ref{f000018} ：


%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f000018,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
]
call "C:/Qt/Qt5.12.0/5.12.0/msvc2017_64/bin/qtenv2.bat"
cd /D "E:/QtQmlBookMsvc"
qmake -r -tp vc "E:/QtQmlBook/QtQmlBook.pro"
qmake -r -tp vc "E:/QtQmlBook/QtQmlMultimedia.pro"
qmake -r -tp vc "E:/QtQmlBook/QtQmlBookTest.pro"
qmake -r -tp vc "E:/QtQmlBook/TheBook/TheBook.pro"
cmd(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}



\begin{itemize}

\item 第1行用于设置Qt运行环境；
\item 第2行用于设置Visual Studio工程文件输出目录；
\item 第3\raisebox{0.16ex}{\sourcefonttwo\~{}}6行用于指明将哪些qmake项目转为Visual Studio项目；

\end{itemize}

运行完上述命令后，读者即可使用Visual Studio打
开“QtQmlBook.sln”

本节示例代码位于文件夹“QtQmlBook/chapter01/firstapplication”下。

\lstlistingname\ \ref{f000019}
展示了
该项目的工程文件：

\begin{itemize}
\item 第11行引入“outdirpath.pri”文件，此文件定义了输出路径。
\item 第13行引入“cplusplus.pri”文件，此文件定义了标准C{\sourcefonttwo{}+}{\sourcefonttwo{}+}相关控制项。
\item 第15行引入“import\underline{\hspace{0.5em}}sstd\underline{\hspace{0.5em}}library.pri”文件，此文件引入“sstd\underline{\hspace{0.5em}}library”库。
“sstd\underline{\hspace{0.5em}}library”库用于引入和补充标准C{\sourcefonttwo{}+}{\sourcefonttwo{}+}库。
\item 第17行引入“import\underline{\hspace{0.5em}}sstd\underline{\hspace{0.5em}}qt\underline{\hspace{0.5em}}and\underline{\hspace{0.5em}}qml\underline{\hspace{0.5em}}library.pri”文件，
此文件引入“sstd\underline{\hspace{0.5em}}qt\underline{\hspace{0.5em}}and\underline{\hspace{0.5em}}qml\underline{\hspace{0.5em}}library”库。
“sstd\underline{\hspace{0.5em}}qt\underline{\hspace{0.5em}}and\underline{\hspace{0.5em}}qml\underline{\hspace{0.5em}}library”库用于引入和补充Qt库。
\item 第44\raisebox{0.16ex}{\sourcefonttwo\~{}}48行将Qml文件加入工程。这是一种惯用法，用于实现Qml国际化。
\end{itemize}

本书的所有工程项目大同小异，以后不再赘述。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(**@}{@**)},
label=f000019,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
]
#firstapplication.pro
TEMPLATE = app

CONFIG(debug,debug|release){
    TARGET = firstapplication_debug
}else{
    TARGET = firstapplication
}

#define out put dir
include($$PWD/../../outdirpath.pri)
#define cplusplus environment
include($$PWD/../../cplusplus.pri)
#import sstd_library
include($$PWD/../../sstd_library/import_sstd_library.pri)
#import sstd_qt_and_qml_library
include($$PWD/../../sstd_qt_and_qml_library/import_sstd_qt_and_qml_library.pri)

!win32 {
    QMAKE_LFLAGS += -Wl,-rpath .
}

win32-msvc*{
    CONFIG += console
}

DEFINES += CURRENT_DEBUG_PATH=\\\"$$PWD\\\"

DESTDIR = $${RootDestDir}

SOURCES += $$PWD/main.cpp

CONFIG(debug,debug|release){
    QMAKE_POST_LINK += $${DESTDIR}/build_install_debug $$PWD "myqml"
}else{
    QMAKE_POST_LINK += $${DESTDIR}/build_install $$PWD "myqml"
}
export(QMAKE_POST_LINK)

QMLSOURCES += $$PWD/myqml/firstapplication/main1.qml
QMLSOURCES += $$PWD/myqml/firstapplication/main2.qml
QMLSOURCES += $$PWD/myqml/firstapplication/main3.qml

lupdate_only{
    SOURCES += $$QMLSOURCES
}

DISTFILES += $$QMLSOURCES(**@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@**)\end{lstlisting}          %抄录环境
%\end{spacing}


%设置Qt Quick运行参数
\FloatBarrier
\subsection{
Qt Quick运行常用设置
}\label{ss001v10}


Qt Quick路径识别依靠QUrl类。
QUrl既可以表达一个网络路径也可以表达一个本地路径。

使用QUrl表达一个本地绝对路径，Windows平台下需要在开头加“file:///”，
POSIX平台下需要在开头加“file://”。

比如，在Windows平台下一个本地绝对路径是“C:/main.qml”，
那么用QUrl表达则为“file:///C:/main.qml”；在Linux平台下
一个本地绝对路径是“/usr/main.qml”，那么
用QUrl表达则为“file:///usr/main.qml”。

\lstlistingname\ \ref{f000026}
展示如何用C{\sourcefonttwo{}+}{\sourcefonttwo{}+}实现这一功能。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f000026,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=6]
inline QUrl getLocalFileFullPath(
    const QString & argFileName,
    const QString & argBase) {
    const QDir varRootDir{ argBase };
    const auto varAns = varRootDir.absoluteFilePath(argFileName);
    if (varAns.startsWith(QChar('/'))) {
        return QStringLiteral(R"(file://)") + varAns;
    } else {
        return QStringLiteral(R"(file:///)") + varAns;
    }
}(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main4.qml

Qt Quick依赖于OpenGL。\lstlistingname\ \ref{f000027}
展示常用OpenGL参数设置：

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(**@}{@**)},
label=f000027,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=18]
inline QSurfaceFormat getDefaultQSurfaceFormat() {
    auto varFormat = QSurfaceFormat::defaultFormat();
    varFormat.setVersion(4, 6);
    varFormat.setProfile(QSurfaceFormat::CoreProfile);
    varFormat.setSamples(4);
    varFormat.setAlphaBufferSize(8);
    varFormat.setBlueBufferSize(8);
    varFormat.setRedBufferSize(8);
    varFormat.setGreenBufferSize(8);
    varFormat.setDepthBufferSize(24);
    varFormat.setSwapBehavior(QSurfaceFormat::DoubleBuffer);
    varFormat.setRenderableType(QSurfaceFormat::OpenGL);
    varFormat.setSwapInterval(0)/*关闭垂直同步*/;
#if defined(ENABLE_GL_DEBUG)
    varFormat.setOption(QSurfaceFormat::DebugContext, true);
#else
    varFormat.setOption(QSurfaceFormat::DebugContext, false);
#endif
    return varFormat;
}(**@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@**)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main5.qml

Qt库依靠事件队列实现消息循环。因而在使用绝大多数Qt组件之前
都要先构造QCoreApplication或其子类。

在构造QCoreApplication之前，
需要设置一些参数。
\lstlistingname\ \ref{f000028}
展示了一些常见设置。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(**@}{@**)},
label=f000028,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=39]
inline void beforeApplication() {
    {
        /*初始化随机种子*/
        ::srand(static_cast<unsigned>(::time(nullptr)));
    }
    {
        /*高分屏支持*/
        QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    }
    {
        /*设置默认opengl环境*/
        QSurfaceFormat::setDefaultFormat(::getDefaultQSurfaceFormat());
    }
}(**@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@**)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main6.qml

在构造完QCoreApplication之后，
还需要加载一些组件。比如QImage组件是依靠插件支持的。
对于一些外存较差的设备而言，加载插件可能会造成几百毫秒
甚至数秒的卡顿。为了程序运行平滑，这些组件都是预加载的。

\lstlistingname\ \ref{f000029}
展示了如何实现这一操作。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f000029,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=54]
inline void afterApplication() {
    {
        QImage varImage{QStringLiteral("test.png")};
        (void)varImage;
    }
}(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main7.qml

\lstlistingname\ \ref{f00002u}
展示了如何在工程文件中引入常用Qt库。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f00002u,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
]
QT += gui
QT += qml
QT += core
QT += quick
QT += widgets
QT += concurrent
QT += quickwidgets
QT += quickcontrols2(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}
 %import_sstd_qt_and_qml_library.1.pri

\FloatBarrier
\subsection{
使用QQuickView加载Qt Quick程序
}\label{ss001010}


QQuickView自Qt 5.0引入。

QQuickView被设计用来提供一个在显示器上
呈现Qml渲染结果的一个集成环境。
如果读者需要在移动设备上呈现Qml，
QQuickView是一个好的选择。

\lstlistingname\ \ref{f000020}
展示了使用QQuickView加载Qml的C{\sourcefonttwo{}+}{\sourcefonttwo{}+}代码\footnote{
将宏QML\underline{\hspace{0.5em}}USE\underline{\hspace{0.5em}}WINDOW\underline{\hspace{0.5em}}TYPE的值改为1。
}；
\lstlistingname\ \ref{f000023}
展示了一个简单显示一个红色窗口的Qml代码。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f000020,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=67]
beforeApplication();
QGuiApplication varApp{ argc,argv };
afterApplication();
QQuickView varView;
varView.setResizeMode(QQuickView::ResizeMode::SizeViewToRootObject);
#ifdef _DEBUG
varView.setSource(
    getLocalFileFullPath(
        QStringLiteral("myqml/firstapplication/main1.qml"),
        CURRENT_DEBUG_PATH));
#else
varView.setSource(
    getLocalFileFullPath(
        QStringLiteral("myqml/firstapplication/main1.qml"),
        qApp->applicationDirPath()));
#endif
if (varView.status() != QQuickView::Status::Ready) {
    qWarning() << QStringLiteral("can not load : main1.qml");
    return -1;
}
varView.show();
return varApp.exec();(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main.cpp
%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(**@}{@**)},
label=f000023,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
]
/*main1.qml*/
import QtQuick 2.9

Rectangle{

    width: 512 ;
    height: 512 ;
    color: Qt.rgba(1,0,0,1);

}/*Rectangle*/(**@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@**)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main1.qml

如\lstlistingname\ \ref{f000020}
的72\raisebox{0.16ex}{\sourcefonttwo\~{}}82行所示，本书在Debug模式下从当前
项目目录下载入Qml文件，而在Release模式下
从应用程序目录下载入Qml文件。

将当前项目目录文件拷贝到应用程序目录是依靠本书自带的
一个小工具“build\underline{\hspace{0.5em}}install”达成的。
此工具对于非qml文件仅仅是拷贝，而对于qml文件做了更多处理。
后续章节会有介绍。

\FloatBarrier
\subsection{
使用QQuickWidget加载Qt Quick程序
}\label{ss001110}


QQuickWidget自Qt 5.3引入。

引入QQuickWidget的目的就是混用
Qt Quick和Qt Widgets。
但实际上，使用QQuickWidget加载Qml和使用QQuickView加载Qml的
根本区别在于：
QQuickWidget是同步渲染的，而QQuickView是异步渲染的。

对于一些小型应用程序，异步渲染是不必要的。
而更重要的是，在一些设备上，由于硬件限制，异步渲染是低效甚至
不可实现的。即使可以实现，也可能有一些莫名其妙的BUG。

对于以上情形，
使用QQuickWidget比使用QQuickView能够获得
更好的效果，甚至能消除一些BUG。

\lstlistingname\ \ref{f000021}
展示了使用QQuickWidget加载Qml的C{\sourcefonttwo{}+}{\sourcefonttwo{}+}代码\footnote{
将宏QML\underline{\hspace{0.5em}}USE\underline{\hspace{0.5em}}WINDOW\underline{\hspace{0.5em}}TYPE的值改为2。
}；
\lstlistingname\ \ref{f000024}
展示了一个简单显示一个红色窗口的Qml代码。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f000021,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=90]
beforeApplication();
QApplication varApp{ argc,argv };
afterApplication();
QQuickWidget varWidget;
varWidget.setResizeMode(QQuickWidget::ResizeMode::SizeViewToRootObject);
#ifdef _DEBUG
varWidget.setSource(getLocalFileFullPath(
    QStringLiteral("myqml/firstapplication/main2.qml"),
    CURRENT_DEBUG_PATH));
#else
varWidget.setSource(getLocalFileFullPath(
    QStringLiteral("myqml/firstapplication/main2.qml"),
    qApp->applicationDirPath()));
#endif
if (varWidget.status() != QQuickWidget::Status::Ready) {
    qWarning() << QStringLiteral("can not load : main2.qml");
    return -1;
}
varWidget.show();
return varApp.exec();(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main.cpp
%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(**@}{@**)},
label=f000024,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
]
/*main2.qml*/
import QtQuick 2.9

Rectangle{

    width: 512 ;
    height: 512 ;
    color: Qt.rgba(1,0,0,1);

/*begin:debug*/
    border.width: 9 ;
/*end:debug*/


}/*Rectangle*/(**@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@**)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main2.qml

读者可以分别在Debug和Release模式下运行此程序，会发现Debug
模式比Release模式多了一个边框。这一切都是靠本书自带的小工具
“build\underline{\hspace{0.5em}}install”实现的。

如\lstlistingname\ \ref{f000024}
的10\raisebox{0.16ex}{\sourcefonttwo\~{}}12行所示。本书自带的小工具“build\underline{\hspace{0.5em}}install”在拷贝
qml文件时会将/\raisebox{-0.35ex}{\sourcefonttwo{}*}begin:debug\raisebox{-0.35ex}{\sourcefonttwo{}*}/和/\raisebox{-0.35ex}{\sourcefonttwo{}*}end:debug\raisebox{-0.35ex}{\sourcefonttwo{}*}/之间的内容
替换为注释。

读者采用此小工具可以达到一些调试效果。

\FloatBarrier
\subsection{
使用QQmlApplicationEngine加载Qt Quick程序
}\label{ss001210}


QQmlApplicationEngine自Qt 5.1引入。

引入QQmlApplicationEngine的目的是为了能够实现Qt Quick Controls。

QQmlApplicationEngine是对
QQuickView的进一步包装和扩展。
Qt Quick Controls一些控件比如“对话框”需要一些
全局支持。
QQmlApplicationEngine就是被设计用来提供这些全局支持的。

如果读者不需要传统对话框的话，
QQuickView或QQuickWidget也是足够使用的。
但如果使用类似于对话框这样的功能，还是建议
读者使用QQmlApplicationEngine。

\lstlistingname\ \ref{f000022}
展示了使用QQuickWidget加载Qml的C{\sourcefonttwo{}+}{\sourcefonttwo{}+}代码\footnote{
将宏QML\underline{\hspace{0.5em}}USE\underline{\hspace{0.5em}}WINDOW\underline{\hspace{0.5em}}TYPE的值改为3。
}；
\lstlistingname\ \ref{f000025}
展示了一个简单显示一个红色窗口的Qml代码。

%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(*@}{@*)},
label=f000022,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
,firstnumber=111]
beforeApplication();
QGuiApplication varApp{ argc,argv };
afterApplication();
#ifdef _DEBUG
QQmlApplicationEngine varEngine(getLocalFileFullPath(
    QStringLiteral("myqml/firstapplication/main3.qml"),
    CURRENT_DEBUG_PATH));
#else
QQmlApplicationEngine varEngine(getLocalFileFullPath(
    QStringLiteral("myqml/firstapplication/main3.qml"),
    qApp->applicationDirPath()));
#endif
if (varEngine.rootObjects().isEmpty()) {
    qWarning() << QStringLiteral("can not load : main3.qml");
    return -1;
}
return varApp.exec();(*@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@*)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main.cpp
%\begin{spacing}{1.0}
\FloatBarrier
\begin{lstlisting}[escapeinside={(**@}{@**)},
label=f000025,
caption=GoodLuck,
title=\lstlistingname\ \thelstlisting
]
/*main3.qml*/
import QtQuick 2.9
import QtQuick.Controls 2.5

ApplicationWindow {

    width: 512 ;
    height: 512 ;
    visible: true ;

    Rectangle{
        anchors.fill: parent ;
        color: Qt.rgba(1,0,0,1);

        /*begin:debug*/
        border.width: 9 ;
        /*end:debug*/

    }/*Rectangle*/

}(**@\marginpar{\fbox{\footnotesize{\lstlistingname\ \thelstlisting}}}@**)\end{lstlisting}          %抄录环境
%\end{spacing}
 %main3.qml
































%使用xelatex编译
%版权所有，翻版必究
%本文件由程序自动生成，任何修改将被覆盖
%2019 年 01 月 09 日



